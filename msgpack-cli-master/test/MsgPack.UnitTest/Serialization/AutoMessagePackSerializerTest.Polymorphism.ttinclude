<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#+
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010-2015 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

// Entry Point
private void GeneratePolymorphismTestParts()
{
	this.GeneratePolymorphismTestPartsCore( false, true );
}

private void GeneratePolymorphismTestTypes()
{
	this.GeneratePolymorphismTestPartsCore( true, false );
}

private IEnumerable<TestTargetType> GetSerialiazablePolymprohicTestTypeNames()
{
	return this.GeneratePolymorphismTestPartsCore( false, false );
}

private IEnumerable<TestTargetType> GeneratePolymorphismTestPartsCore( bool generateTypes, bool generateMethods )
{
	ICollection<TestTargetType> generatedSerializableTypeNames = new HashSet<TestTargetType>();

	Func<Member, bool, IEnumerable<string>> knownAttributeFactory =
		( Member member, bool asObject  ) => 
		{
			switch ( member.Targets )
			{
				case PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.ActualTypes.Select(
								( t, i ) =>
									String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownCollectionItemType( \"{0}\", typeof( {1} ) )]", i, t ) 
							)
						);
				}
				case PolymorphismTargets.Key:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.ActualTypes.Select(
								( t, i ) =>
									String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownDictionaryKeyType( \"{0}\", typeof( {1} ) )]", i, t ) 
								)
						);
				}
				case PolymorphismTargets.Key | PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.ActualTypes.Select( ( t, i ) => String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownDictionaryKeyType( \"{0}\", typeof( {1} ) )]", i, t ) ) 
						).Concat(
							member.ActualTypes.Select( ( t, i ) => String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownCollectionItemType( \"{0}\", typeof( {1} ) )]", i, t ) )
						);
				}
				case PolymorphismTargets.TupleItem:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.PolymorphicTupleItemTypes.SelectMany(
								kv =>
									kv.Value.Select(
										( t, i ) =>
											String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownTupleItemType( {0}, \"{1}\", typeof( {2} ) )]", kv.Key, i, t )
									)
							)
						);
				}
				case PolymorphismTargets.Member:
				{
					return member.ActualTypes.Select( ( t, i ) => String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownType( \"{0}\", typeof( {1} ) )]", i, t ) );
				}
				default:
				{
					return Enumerable.Empty<string>();
				}
			}
		};
	Func<Member, bool, IEnumerable<string>> runtimeAttributeFactory = 
		( Member member, bool asObject ) => 
		{
			switch ( member.Targets )
			{
				case PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat( new[] { "[MessagePackRuntimeCollectionItemType]" } );
				}
				case PolymorphismTargets.Key:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat( new[] { "[MessagePackRuntimeDictionaryKeyType]" } );
				}
				case PolymorphismTargets.Key | PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							new[]
							{
								"[MessagePackRuntimeCollectionItemType]",
								"[MessagePackRuntimeDictionaryKeyType]"
							} 
						);
				}
				case PolymorphismTargets.TupleItem:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.PolymorphicTupleItemTypes.Select(
								kv => String.Format( CultureInfo.InvariantCulture, "[MessagePackRuntimeTupleItemType( {0} )]", kv.Key )
							)
						);
				}
				case PolymorphismTargets.Member:
				{
					return new [] { "[MessagePackRuntimeType]" };
				}
				default:
				{
					return Enumerable.Empty<string>();
				}
			}
		};

	var attributeTypes =
		new [] 
		{ 
			new { Name = "KnownType", AttributeFactory = knownAttributeFactory },
			new { Name = "RuntimeType", AttributeFactory = runtimeAttributeFactory },
		};
	var normalTypes =
		new []
		{
			Member.Of( "Reference",		"Version" ,			PolymorphismTargets.None,	null, @"null",					@"new Version( 1, 2, 3, 4 )" ),
			Member.Of( "Value",			"DateTime",			PolymorphismTargets.None,	null, @"default( DateTime )",	@"new DateTime( 1982, 1, 29, 15, 46, 12, DateTimeKind.Utc )" ),
			Member.Of( "Primitive",		"int",				PolymorphismTargets.None,	null, @"default( int )",		@"123" ),
			Member.Of( "String",		"string",			PolymorphismTargets.None,	null, @"null",					@"""ABC""" ),
			Member.Of( "Polymorphic",	"FileSystemEntry",	PolymorphismTargets.Member,	null, @"null",					@"new FileEntry { Name = ""file"", Size = 1 }", "FileEntry", "DirectoryEntry" ),
		};
	var collectionTypes =
		new []
		{
			Member.Of( "ListStaticItem",		"IList<string>",			PolymorphismTargets.None,	false,	@"new List<string>()",			@"new List<string>{ ""A"", ""B"" }" ),
			Member.Of( "ListPolymorphicItem",	"IList<FileSystemEntry>",	PolymorphismTargets.Item,	false,	@"new List<FileSystemEntry>()",	@"new List<FileSystemEntry>{ new FileEntry { Name = ""file"", Size = 1L }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "ListObjectItem",		"IList<object>",			PolymorphismTargets.Item,	false,	@"new List<object>()",			@"new List<object>{ new FileEntry { Name = ""file"", Size = 1L }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "ListPolymorphicItself",	"IList<string>",			PolymorphismTargets.Member,	false,	@"new Collection<string>()",	@"new Collection<string>{ ""A"", ""B"" }", "Collection<string>", "List<string>" ),
			Member.Of( "ListObjectItself",		"object",					PolymorphismTargets.Member,	true,	@"new Collection<string>()",	@"new Collection<string>{ ""A"", ""B"" }", "Collection<string>", "List<string>" ),
		};
	var dictionaryTypes =
		new []
		{
			Member.Of( "DictStaticKeyAndStaticItem",		"IDictionary<string, string>",						PolymorphismTargets.None,							false,	@"new Dictionary<string, string>()",					@"new Dictionary<string, string>{ { ""A"", ""A"" }, { ""B"", ""B"" } }" ),
			Member.Of( "DictPolymorphicKeyAndStaticItem",	"IDictionary<FileSystemEntry, string>",				PolymorphismTargets.Key,							false,	@"new Dictionary<FileSystemEntry, string>()",			@"new Dictionary<FileSystemEntry, string>{ { new FileEntry { Name = ""file"", Size = 1L }, ""A"" }, { new DirectoryEntry { Name = ""dir"", ChildCount = 1 }, ""B"" } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictObjectKeyAndStaticItem",		"IDictionary<object, string>",						PolymorphismTargets.Key,							false,	@"new Dictionary<object, string>()",					@"new Dictionary<object, string>{ { new FileEntry { Name = ""file"", Size = 1L }, ""A"" }, { new DirectoryEntry { Name = ""dir"", ChildCount = 1 }, ""B"" } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictStaticKeyAndPolymorphicItem",	"IDictionary<string, FileSystemEntry>",				PolymorphismTargets.Item,							false,	@"new Dictionary<string, FileSystemEntry>()",			@"new Dictionary<string, FileSystemEntry>{ { ""A"", new FileEntry { Name = ""file"", Size = 1L } }, { ""B"", new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictStaticKeyAndObjectItem",		"IDictionary<string, object>",						PolymorphismTargets.Item,							false,	@"new Dictionary<string, object>()",					@"new Dictionary<string, object>{ { ""A"", new FileEntry { Name = ""file"", Size = 1L } }, { ""B"", new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictPolymorphicKeyAndItem",			"IDictionary<FileSystemEntry, FileSystemEntry>",	PolymorphismTargets.Key | PolymorphismTargets.Item,	false,	@"new Dictionary<FileSystemEntry, FileSystemEntry>()",	@"new Dictionary<FileSystemEntry, FileSystemEntry>{ { new FileEntry { Name = ""A"", Size = 1L }, new FileEntry { Name = ""file"", Size = 1L } }, { new DirectoryEntry { Name = ""B"", ChildCount = 1 }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictObjectKeyAndItem",				"IDictionary<object, object>",						PolymorphismTargets.Key | PolymorphismTargets.Item,	false,	@"new Dictionary<object, object>()",					@"new Dictionary<object, object>{ { new FileEntry { Name = ""A"", Size = 1L }, new FileEntry { Name = ""file"", Size = 1L } }, { new DirectoryEntry { Name = ""B"", ChildCount = 1 }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictPolymorphicItself",				"IDictionary<string, string>",						PolymorphismTargets.Member,							false,	@"new Dictionary<string, string>()",					@"new Dictionary<string, string>{ { ""A"", ""A"" }, { ""B"", ""B"" } }", "Dictionary<string, string>", "SortedDictionary<string, string>" ),
			Member.Of( "DictObjectItself",					"object",											PolymorphismTargets.Member,							true,	@"new Dictionary<string, string>()",					@"new Dictionary<string, string>{ { ""A"", ""A"" }, { ""B"", ""B"" } }", "Dictionary<string, string>", "SortedDictionary<string, string>" ),
		};
	var tupleMembers =
		new []
		{
			Member.Of( "Tuple1Static",				"Tuple<string>", 
													false,
													@"Tuple.Create( ""1"" )" ),
			Member.Of( "Tuple1Polymorphic",			"Tuple<FileSystemEntry>",
													false,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as FileSystemEntry )",
													new KeyValuePair<int, string[]>( 1, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple1ObjectItem",			"Tuple<object>",
													false,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as object )",
													new KeyValuePair<int, string[]>( 1, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple1ObjectItself",		"object",
													true,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as FileEntry )" // Tuple items can be polymorphic only when tuple itself declared as Tuple.
													), // Tuple items can be polymorphic only when tuple itself declared as Tuple.
			Member.Of( "Tuple7AllStatic",			"Tuple<string, string, string, string, string, string, string>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + " )" ),
			Member.Of( "Tuple7FirstPolymorphic",	"Tuple<FileSystemEntry, string, string, string, string, string, string>",
													false,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as FileSystemEntry, " + String.Join( ", ", Enumerable.Range( 2, 6 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + ")",
													new KeyValuePair<int, string[]>( 1, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple7LastPolymorphic",		"Tuple<string, string, string, string, string, string, FileSystemEntry>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 6 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", new FileEntry { Name = ""7"", Size = 7 } as FileSystemEntry )",
													new KeyValuePair<int, string[]>( 7, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple7MidPolymorphic",		"Tuple<string, string, string, FileSystemEntry, string, string, string>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 3 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", new FileEntry { Name = ""4"", Size = 4 } as FileSystemEntry, " + String.Join( ", ", Enumerable.Range( 5, 3 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + ")",
													new KeyValuePair<int, string[]>( 4, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple7AllPolymorphic",		"Tuple<FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"new {0}Entry {{ Name = ""{1}"", {2} = {1} }} as FileSystemEntry", i % 2 == 1 ? "File" : "Directory", i, i % 2 == 1 ? "Size" : "ChildCount" ) ) ) + " )",
													Enumerable.Range( 1, 7 ).Select( i => new KeyValuePair<int, string[]>( i, new []{ "FileEntry", "DirectoryEntry" } ) ).ToArray() ),
			Member.Of( "Tuple8AllStatic",			"Tuple<string, string, string, string, string, string, string, Tuple<string>>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", ""8"" )" ),
			Member.Of( "Tuple8LastPolymorphic",		"Tuple<string, string, string, string, string, string, string, Tuple<FileSystemEntry>>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", new FileEntry { Name = ""8"", Size = 8 } as FileSystemEntry )",
													new KeyValuePair<int, string[]>( 8, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple8AllPolymorphic",		"Tuple<FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, Tuple<FileSystemEntry>>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"new {0}Entry {{ Name = ""{1}"", {2} = {1} }} as FileSystemEntry", i % 2 == 1 ? "File" : "Directory", i, i % 2 == 1 ? "Size" : "ChildCount" ) ) ) + @", new DirectoryEntry { Name = ""8"", ChildCount = 8 } as FileSystemEntry )",
													Enumerable.Range( 1, 8 ).Select( i => new KeyValuePair<int, string[]>( i, new []{ "FileEntry", "DirectoryEntry" } ) ).ToArray() ),
		};

	if ( generateTypes || generateMethods )
	{
#>
		#region -- Polymorphism --
<#+
	}

	foreach ( var attributeType in attributeTypes )
	{
		if ( generateTypes || generateMethods )
		{
#>
		#region ---- <#= attributeType.Name #> ----

		#region ------ <#= attributeType.Name #>.NormalTypes ------
<#+
		}

		foreach ( var member in normalTypes )
		{
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyPropertyAndConstructor, TypeKind.PrivateSetterPropertyAndConstructor, TypeKind.ReadOnlyFieldAndConstructor } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_Normal_" + member.Name + kind, kind, member, attributeType.AttributeFactory, false, generateTypes );
				generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, false );
				
				var typeNameAsObject = GeneratePolymorphicTestType( attributeType.Name + "_" + member.Name + kind + "AsObject", kind, member, attributeType.AttributeFactory, true, generateTypes );
				
				if ( !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add(  new TestTargetType( typeNameAsObject, true ) );
				}

				GeneratePolymorphicTestMethods( typeNameAsObject, kind, member, generateMethods, true );
			}
		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.NormalTypes ------

		#region ------ <#= attributeType.Name #>.CollectionTypes ------
<#+
		}

		foreach( var member in collectionTypes )
		{
			// Note: combination of deserialization constructor and collection get/read only member is not valid.
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyCollectionProperty, TypeKind.PrivateSetterCollectionProperty, TypeKind.ReadOnlyCollectionField } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_List_" + member.Name + kind, kind, member, attributeType.AttributeFactory, member.AsObject.Value, generateTypes );
				
				if ( !member.AsObject.Value || !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				}
				
				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, member.AsObject.Value );
			}
		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.CollectionTypes ------

		#region ------ <#= attributeType.Name #>.DictionaryTypes ------
<#+
		}

		foreach( var member in dictionaryTypes )
		{
			// Note: combination of deserialization constructor and collection get/read only member is not valid.
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyCollectionProperty, TypeKind.PrivateSetterCollectionProperty, TypeKind.ReadOnlyCollectionField } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_Dict_" + member.Name + kind, kind, member, attributeType.AttributeFactory, member.AsObject.Value, generateTypes );
				
				if ( !member.AsObject.Value || !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				}

				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, member.AsObject.Value );
			}
		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.DictionaryTypes ------

#if !NETFX_35 && !UNITY
		#region ------ <#= attributeType.Name #>.TupleTypes ------
<#+
		}

		foreach ( var member in tupleMembers )
		{
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyPropertyAndConstructor, TypeKind.PrivateSetterPropertyAndConstructor, TypeKind.ReadOnlyFieldAndConstructor } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_Tuple_" + member.Name + kind, kind, member, attributeType.AttributeFactory, member.AsObject.Value, generateTypes );
				
				if ( !member.AsObject.Value || !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, false ) );
				}

				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, member.AsObject.Value );
			}

		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.TupleTypes ------
#endif // #if !NETFX_35 && !UNITY

		#endregion ---- <#= attributeType.Name #> ----
<#+
		}
	}

	// Mixed Patterns
	GeneratePolymorphicTestsForMixed( generateTypes, generateMethods, generatedSerializableTypeNames );

	// Error Patterns
	GenerateErrorPatterns( generateTypes, generateMethods, generatedSerializableTypeNames );

	if ( generateTypes )
	{
		// Add static generated types
		generatedSerializableTypeNames.Add( new TestTargetType( "IFileSystemEntry", true ) );
		generatedSerializableTypeNames.Add( new TestTargetType( "AbstractFileSystemEntry", true ) );
		generatedSerializableTypeNames.Add( new TestTargetType( "FileEntry", true ) );
		generatedSerializableTypeNames.Add( new TestTargetType( "DirectoryEntry", true ) );
#>

		public interface IFileSystemEntry { }

		public abstract class AbstractFileSystemEntry : IFileSystemEntry { }

		public abstract class FileSystemEntry : AbstractFileSystemEntry, IComparable<FileSystemEntry>
		{
			public string Name { get; set; }

			public override bool Equals( object obj )
			{
				var other = obj as FileSystemEntry;
				if ( Object.ReferenceEquals( other, null ) )
				{
					return false;
				}

				return this.Name == other.Name;
			}

			public override int GetHashCode()
			{
				return ( this.Name ?? String.Empty ).GetHashCode();
			}

			int IComparable<FileSystemEntry>.CompareTo( FileSystemEntry other )
			{
				return String.Compare( this.Name, other.Name, StringComparison.Ordinal );
			}
		}

		public class FileEntry : FileSystemEntry
		{
			public long Size { get; set; }

			public override bool Equals( object obj )
			{
				var other = obj as FileEntry;
				if ( Object.ReferenceEquals( other, null ) )
				{
					return false;
				}

				return this.Name == other.Name && this.Size == other.Size;
			}

			public override int GetHashCode()
			{
				return ( this.Name ?? String.Empty ).GetHashCode() ^ this.Size.GetHashCode();
			}

			public override string ToString()
			{
				return "File(Name=" + this.Name + ", Size=" + this.Size + ")";
			}
		}

		public class DirectoryEntry : FileSystemEntry
		{
			public int ChildCount { get; set; }

			public override bool Equals( object obj )
			{
				var other = obj as DirectoryEntry;
				if ( Object.ReferenceEquals( other, null ) )
				{
					return false;
				}

				return this.Name == other.Name && this.ChildCount == other.ChildCount;
			}

			public override int GetHashCode()
			{
				return ( this.Name ?? String.Empty ).GetHashCode() ^ this.ChildCount.GetHashCode();
			}

			public override string ToString()
			{
				return "Directory(Name=" + this.Name + ", ChildCount=" + this.ChildCount + ")";
			}
		}
<#+
	}

	if ( generateTypes || generateMethods )
	{
#>

		#endregion -- Polymorphism --
<#+
	}

	return generatedSerializableTypeNames;
}

// Types
private string GeneratePolymorphicTestType( string suffix, TypeKind kind, Member member, Func<Member, bool, IEnumerable<string>> attributeFactory, bool asObject, bool generateTypes )
{
	var typeName = "PolymorphicMemberType" + suffix;

	if ( generateTypes )
	{
#>

		public class <#= typeName #>
		{
<#+
		GenerateMember( kind, member, attributeFactory, asObject );
#>

<#+
		GenerateConstructor( typeName, kind, asObject, member );
#>
		}
<#+
	}

	return typeName;
}

// Types (private)
private void GenerateMember( TypeKind kind, Member member, Func<Member, bool, IEnumerable<string>> attributeFactory, bool asObject )
{

	if ( ( kind & TypeKind.PropertyOrFieldMask ) == TypeKind.Field )
	{
		GenerateAttributes( member, attributeFactory, asObject );
#>
			public <#= ( kind & TypeKind.IsReadOnly ) == TypeKind.IsReadOnly ? "readonly" : String.Empty #> <#= asObject ? "object" : member.Type #> <#=  GetMemberNameGenerator( kind )( member.Name ) #>;
<#+
	}
	else
	{
		var backingField = GetMemberNameGenerator( TypeKind.Property )( member.Name );

#>
			private <#= asObject ? "object" : member.Type #> <#=  backingField #>;

<#+
		GenerateAttributes( member, attributeFactory, asObject );
#>
			public <#= asObject ? "object" : member.Type #> <#=  GetMemberNameGenerator( TypeKind.Field )( member.Name ) #>
			{
				get { return this.<#= backingField #>; }
<#+
		if ( ( kind & TypeKind.HasSetter ) == TypeKind.HasSetter )
		{
#>
				<#= ( kind & TypeKind.IsPublicSetter ) == TypeKind.IsPublicSetter ? String.Empty : "private" #> set { this.<#= backingField #> = value; }
<#+
		}
#>
			}
<#+
	}
}

private void GenerateAttributes( Member member, Func<Member, bool, IEnumerable<string>> attributeFactory, bool asObject )
{
	foreach ( var attribute in attributeFactory( member, asObject ) )
	{
#>
			<#= attribute #>
<#+
	}
}

private void GenerateConstructor( string typeName, TypeKind kind, bool asObject, params Member[] members )
{
#>

			<#= ( kind & TypeKind.HasConstructor ) == TypeKind.HasConstructor ? "public" : "private" #> <#= typeName #>( <#=  String.Join( ", ", members.Select( member => ( asObject ? "object" : member.Type ) + " " + member.Name ) ) #> ) 
			{
<#+
	foreach ( var member in members )
	{
#>
				this.<#=  GetMemberNameGenerator( kind )( member.Name ) #> = <#= member.Name #>;
<#+
	}
#>
			}
<#+
	if ( ( kind & TypeKind.HasConstructor ) == 0 )
	{
#>

			public <#= typeName #>()
			{
<#+
	foreach ( var member in members )
	{
#>
				this.<#=  GetMemberNameGenerator( kind )( member.Name ) #> = <#= member.EmptyValue #>;
<#+
	}
#>
			}

			public static <#= typeName #> Initialize()
			{
				return new <#= typeName #>( <#= String.Join( ", ", members.Select( m => m.InitialValue ) ) #> );
			}
<#+
	}
	else
	{
#>
			public <#= typeName #>() {}
<#+
	}
}

private static bool WillFail( PolymorphismTargets targets, TypeKind kind )
{
	return
		targets != PolymorphismTargets.None
		&& ( kind & TypeKind.HasConstructor ) == 0
		&& (
			( ( kind & TypeKind.HasSetter ) == 0 && ( kind & TypeKind.PropertyOrFieldMask ) == TypeKind.Property )
			|| ( kind & TypeKind.IsReadOnly ) != 0
		);
}

// Methods
private void GeneratePolymorphicTestMethods( string targetType, TypeKind kind, Member member, bool generateMethods, bool asObject )
{
	if ( !generateMethods )
	{
		return;
	}

	var label = "Success";
	var exceptionInCreation = default( string );
	var shouldBeMpo = false;
	if ( asObject )
	{
		switch ( member.Targets )
		{
			case PolymorphismTargets.None:
			{
				shouldBeMpo = true;
				label = "AsMpo";
				break;
			}
			default:
			{
				if ( WillFail( member.Targets, kind ) )
				{
					label = "Fail";
					exceptionInCreation = "SerializationException";
				}

				break;
			}
		}
	}
#>

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= targetType + "_" + label #>()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
<#+
	if ( ( kind & TypeKind.HasConstructor ) == TypeKind.HasConstructor )
	{
#>
			var target = new <#= targetType #>( <#= member.InitialValue #> );
<#+
	}
	else
	{
#>
			var target = <#= targetType #>.Initialize();
<#+
	}

	if ( exceptionInCreation != null )
	{
#>
			Assert.Throws<#= "<" + exceptionInCreation + ">" #>( () => context.GetSerializer<#= "<" + targetType + ">" #>() );
<#+
	}
	else
	{
#>
			var serializer = context.GetSerializer<#= "<" + targetType + ">" #>();
				
			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
<#+
		if ( shouldBeMpo )
		{
#>
				Assert.That( result.<#= member.Name #>, Is.InstanceOf( typeof( MessagePackObject ) ) );
<#+
		}
		else
		{
			if ( member.PolymorphicTupleItemTypes.Length > 0 && asObject )
			{
#>
				// Tuple items cannot be polymorphic when the member itself declared as Object.
<#+
			}
			else
			{
#>
				Assert.That( result.<#= member.Name #>, Is.EqualTo( target.<#= member.Name #> ) );
<#+
			}
#>
				Assert.That( result.<#= member.Name #>, Is.InstanceOf( target.<#= member.Name #>.GetType() ) );
<#+
		}
#>
			}
<#+
	}
#>
		}
<#+
}

// Mixed Pattern
private void GeneratePolymorphicTestsForMixed( bool generateTypes, bool generateMethods, ICollection<TestTargetType> generatedSerializableTypeNames )
{
	/*
		Tests only popular cases:
		Normal : Plane, Runtime/Object, Known
		List : Plain, Plain & Item-Known, Container-Known & Item-Runtime/Object, 
		Dictionary : Plain, Plaiun & Key-Plain & Item-Known, Container-Known & Key-Plain & Item-Runtime/Object, 
		Tuple : (Plane, Known, Runtime, Object)
	 */
	var members =
		new []
		{
			new { Name = "NormalVanilla",	Type = "string",			InitialValue = @"""ABC""",										Attributes = new string[ 0 ], IsTuple = false },
			new { Name = "NormalRuntime",	Type = "FileSystemEntry",	InitialValue = @"new FileEntry { Name = ""File"", Size = 1 }",	Attributes = new [] { "[MessagePackRuntimeType]" }, IsTuple = false },
			new { Name = "NormalKnown",		Type = "FileSystemEntry",	InitialValue = @"new FileEntry { Name = ""File"", Size = 2 }",	Attributes = new [] { "[MessagePackKnownType( \"1\", typeof( FileEntry ) )]", "[MessagePackKnownType( \"2\", typeof( DirectoryEntry ) )]" }, IsTuple = false },
			new { Name = "ObjectRuntime",	Type = "Object",			InitialValue = @"new FileEntry { Name = ""File"", Size = 3 }",	Attributes = new [] { "[MessagePackRuntimeType]" }, IsTuple = false },
			new { Name = "ObjectRuntimeOmittedType",	Type = "Object",			InitialValue = @"new MsgPack.UnitTest.TestTypes.OmittedType { Value = ""ABC"" }",	Attributes = new [] { "[MessagePackRuntimeType]" }, IsTuple = false },
			new { Name = "ListVanilla",						Type = "IList<string>",				InitialValue = @"new List<string> { ""ABC"" }",													Attributes = new string[ 0 ], IsTuple = false },
			new { Name = "ListKnownItem",					Type = "IList<FileSystemEntry>",	InitialValue = @"new List<FileSystemEntry> { new FileEntry { Name = ""File"", Size = 1 } }",	Attributes = new [] { "[MessagePackKnownCollectionItemType( \"1\", typeof( FileEntry ) )]", "[MessagePackKnownCollectionItemType( \"2\", typeof( DirectoryEntry ) )]" }, IsTuple = false },
			new { Name = "ListKnwonContainerRuntimeItem",	Type = "IList<FileSystemEntry>",	InitialValue = @"new List<FileSystemEntry> { new FileEntry { Name = ""File"", Size = 2 } }",	Attributes = new [] { "[MessagePackKnownType( \"1\", typeof( Collection<FileSystemEntry> ) )]", "[MessagePackKnownType( \"2\", typeof( List<FileSystemEntry> ) )]", "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "ListObjectRuntimeItem",			Type = "IList<object>",				InitialValue = @"new List<object> { new FileEntry { Name = ""File"", Size = 3 } }",				Attributes = new [] { "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "DictionaryVanilla",						Type = "IDictionary<string, string>",			InitialValue = @"new Dictionary<string, string> { { ""Key"", ""ABC"" } }",												Attributes = new string[ 0 ], IsTuple = false },
			new { Name = "DictionaryKnownValue",					Type = "IDictionary<string, FileSystemEntry>",	InitialValue = @"new Dictionary<string, FileSystemEntry> { { ""Key"", new FileEntry { Name = ""File"", Size = 1 } } }",	Attributes = new [] { "[MessagePackKnownCollectionItemType( \"1\", typeof( FileEntry ) )]", "[MessagePackKnownCollectionItemType( \"2\", typeof( DirectoryEntry ) )]" }, IsTuple = false },
			new { Name = "DictionaryKnownContainerRuntimeValue",	Type = "IDictionary<string, FileSystemEntry>",	InitialValue = @"new Dictionary<string, FileSystemEntry> { { ""Key"", new FileEntry { Name = ""File"", Size = 2 } } }",	Attributes = new [] { "[MessagePackKnownType( \"1\", typeof( SortedDictionary<string, FileSystemEntry> ) )]", "[MessagePackKnownType( \"2\", typeof( Dictionary<string, FileSystemEntry> ) )]", "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "DictionaryObjectRuntimeValue",			Type = "IDictionary<string, object>",			InitialValue = @"new Dictionary<string, object> { { ""Key"", new FileEntry { Name = ""File"", Size = 3 } } }",			Attributes = new [] { "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "Tuple",	Type = "Tuple<string, FileSystemEntry, FileSystemEntry, object>", InitialValue = @"Tuple.Create<string, FileSystemEntry, FileSystemEntry, object>( ""ABC"", new FileEntry { Name = ""File"", Size = 1 }, new FileEntry { Name = ""File"", Size = 3 }, new FileEntry { Name = ""File"", Size = 3 } )", Attributes = new [] { "[MessagePackKnownTupleItemType( 2, \"1\", typeof( FileEntry ) )]", "[MessagePackKnownTupleItemType( 2, \"2\", typeof( DirectoryEntry ) )]", "[MessagePackRuntimeTupleItemType( 3 )]","[MessagePackRuntimeTupleItemType( 4 )]" }, IsTuple = true },
		};

	const string typeName = "PolymorphicMemberTypeMixed";

	// Add static generated types
	generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
	if ( generateTypes )
	{
#>
		public class <#= typeName #>
		{
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NETFX_35 && !UNITY
<#+
			}

			foreach ( var attribute in member.Attributes )
			{
#>
			<#= attribute #>
<#+
			}
#>
			public <#= member.Type #> <#= member.Name #> { get; set; }
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NETFX_35 && !UNITY
<#+
			}
		}
#>

			public <#= typeName #>() { }
		}
<#+
	}

	if ( generateMethods )
	{
#>

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= typeName #>_Success()
		{
				var context = NewSerializationContext( PackerCompatibilityOptions.None );
				var target = new <#= typeName #>();
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NETFX_35 && !UNITY
<#+
			}
#>
				target.<#= member.Name #> = <#= member.InitialValue #>;
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NETFX_35 && !UNITY
<#+
			}
		}
#>
				var serializer = context.GetSerializer<#= "<" + typeName + ">" #>();
				
				using ( var buffer = new MemoryStream() )
				{
					serializer.Pack( buffer, target );
					buffer.Position = 0;
					var result = serializer.Unpack( buffer );

					Assert.That( result, Is.Not.Null );
					Assert.That( result, Is.Not.SameAs( target ) );
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NETFX_35 && !UNITY
<#+
			}
#>
					Assert.That( result.<#= member.Name #>, Is.EqualTo( target.<#= member.Name #> ), "<#= member.Name #>" );
					Assert.That( result.<#= member.Name #>, Is.InstanceOf( target.<#= member.Name #>.GetType() ), "<#= member.Name #>" );
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NETFX_35 && !UNITY
<#+
			}
		}
#>
				}
		}

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= typeName #>_Null_Success()
		{
				var context = NewSerializationContext( PackerCompatibilityOptions.None );
				var target = new <#= typeName #>();
				var serializer = context.GetSerializer<#= "<" + typeName + ">" #>();
				
				using ( var buffer = new MemoryStream() )
				{
					serializer.Pack( buffer, target );
					buffer.Position = 0;
					var result = serializer.Unpack( buffer );

					Assert.That( result, Is.Not.Null );
					Assert.That( result, Is.Not.SameAs( target ) );
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NETFX_35 && !UNITY
<#+
			}
#>
					Assert.That( result.<#= member.Name #>, Is.Null );
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NETFX_35 && !UNITY
<#+
			}
		}
#>
				}
		}
<#+
	}
}

// Error Pattern
private void GenerateErrorPatterns( bool generateTypes, bool generateMethods, ICollection<TestTargetType> generatedSerializableTypeNames )
{
	var abstractTypes =
		new []
		{ 
			new { Name = "AbstractClass", Type = "AbstractFileSystemEntry", ShouldRegister = true, },
			new { Name = "Interface", Type ="IFileSystemEntry", ShouldRegister = false, },
		};
	/*
		Cartesian of
		{Abstract Class | Interface } x { No Attributes | Knwon Attributes | Runtime Attribute } x { Member | Collection Container (Member) | Collection Items | Dictionary Keys}
	 */
	foreach ( var declarationType in abstractTypes )
	{
		foreach ( var pattern in
			// Note: Collection concrete types must be default collection type.
			new []
			{
				new { Name = "Member",		Qualifier = String.Empty,		TypeFormat = default( string ),				InitializerFormat = "new FileEntry { Name = \"file\", Size = 1 }" },
				new { Name = "ListItem",	Qualifier = "CollectionItem",	TypeFormat = "IList<{0}>",					InitializerFormat = "new List<{0}>{{ new FileEntry {{ Name = \"file\", Size = 1 }} }}" },
				new { Name = "DictKey",		Qualifier = "DictionaryKey",	TypeFormat = "IDictionary<{0}, string>",	InitializerFormat = "new Dictionary<{0}, string> {{ {{ new FileEntry {{ Name = \"file\", Size = 1 }}, \"ABC\" }} }}" },
			}
		)
		{
			foreach ( var attribute in 
				new [] 
				{
					new { Name = "NoAttribute",	Attribute = default( string ) },
					new { Name = "KnownType",	Attribute = String.Format( CultureInfo.InvariantCulture, "[MessagePackKnown{0}Type( \"1\", typeof( FileEntry ) )]", pattern.Qualifier ) }, 
					new { Name = "RuntimeType",	Attribute = String.Format( CultureInfo.InvariantCulture, "[MessagePackRuntime{0}Type]", pattern.Qualifier ) },
				}
			)
			{
				var typeName = declarationType.Name + pattern.Name + attribute.Name;
				if ( attribute.Attribute != null )
				{
					// will success
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				}

				if ( generateTypes )
				{
					GenerateAbstractTypeTestClass( typeName, attribute.Attribute, pattern.TypeFormat == null ? declarationType.Type : String.Format( CultureInfo.InvariantCulture, pattern.TypeFormat, declarationType.Type ) );
				}

				if ( generateMethods )
				{
					GenerateAbstractTypeTestMethod( 
						typeName, 
						pattern.TypeFormat == null ? pattern.InitializerFormat : String.Format( CultureInfo.InvariantCulture, pattern.InitializerFormat, declarationType.Type ), 
						null, 
						null,
						pattern.TypeFormat != null, 
						attribute.Attribute != null 
					);
				}
			}
		}
	}

	// Cannot be created because open generic type.
	// generatedSerializableTypeNames.Add( "EchoKeyedCollection<>" );
	if ( generateTypes )
	{
#>

	public class EchoKeyedCollection<TKey, T> : KeyedCollection<TKey, T>
	{
		protected override TKey GetKeyForItem( T item )
		{
			// should be same
			return ( TKey )( object )item;
		}
	}
<#+
	}

	foreach ( var declarationType in 
		new []
		{ 
			new { Name = "AbstractClass", Type = "KeyedCollection<string, string>" },
			new { Name = "Interface", Type ="IList<string>" },
		}
	)
	{
		foreach ( var attribute in 
			new [] 
			{
				new { Name = "NoAttribute",	Attribute = default( string ) },
				new { Name = "KnownType",	Attribute = "[MessagePackKnownType( \"1\", typeof( EchoKeyedCollection<string, string> ) )]" }, 
				new { Name = "RuntimeType", Attribute = "[MessagePackRuntimeType]" },
			}
		)
		{
			var typeName = declarationType.Name + "Collection" + attribute.Name;
			generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
			if ( generateTypes )
			{
				GenerateAbstractTypeTestClass( typeName, attribute.Attribute, declarationType.Type );
			}

			if ( generateMethods )
			{
				GenerateAbstractTypeTestMethod( typeName, "new EchoKeyedCollection<string, string> { \"ABC\" }", declarationType.Type, "EchoKeyedCollection<string, string>", true, true );
			}
		}
	}

	/*
		Cartesian of
		{Abstract Class | Interface } x {Knwon Attributes | Runtime Attribute } for Tuple Items
	 */
	generatedSerializableTypeNames.Add( new TestTargetType( "TupleAbstractType", false ) );
	if ( generateTypes )
	{
#>
#if !NETFX_35 && !UNITY

		public class TupleAbstractType
		{
			[MessagePackKnownTupleItemType( 1, "1", typeof( FileEntry ) )]
			[MessagePackKnownTupleItemType( 2, "1", typeof( FileEntry ) )]
			[MessagePackRuntimeTupleItemType( 3 )]
			[MessagePackRuntimeTupleItemType( 4 )]
			public Tuple<AbstractFileSystemEntry, IFileSystemEntry, AbstractFileSystemEntry, IFileSystemEntry> Value { get; set; }

			public TupleAbstractType() { }
		}

#endif // !NETFX_35 && !UNITY
<#+
	}

	if ( generateMethods )
	{
#>
#if !NETFX_35 && !UNITY
		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestTupleAbstractType_Success()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var target = new TupleAbstractType { Value = Tuple.Create( <#= String.Join( ", ", Enumerable.Range( 1, 4 ).Select( i => String.Format( CultureInfo.InvariantCulture, "new FileEntry {{ Name = \"{0}\", Size = {0} }} as {1}FileSystemEntry", i, i % 2 == 1 ? "Abstract" : "I" ) ) ) #> ) };
			var serializer = context.GetSerializer<TupleAbstractType>();

			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
				Assert.That( result.Value, Is.EqualTo( target.Value ) );
				Assert.That( result.Value, Is.InstanceOf( target.Value.GetType() ) );
			}
		}
#endif // !NETFX_35 && !UNITY
<#+
	}

	/*
		Cartesian of
		{Dup. Known | Dup. Runtime | Knwon and Runtime} x { Member | Collection Items | Collection Keys | Tuple Items}
	 */
	foreach ( var testCase in 
		new []
		{
			new { Name = "DuplicatedKnown", Known = 2, Runtime = 0 },
			new { Name = "KnownAndRuntime", Known = 1, Runtime = 1 },
			// Note: *RuntimeAttribute cannot be duplicate except tuple thanks to AllowMultiple = false
		}
	)
	{
		var typeNameMember = testCase.Name + "Member";
		if ( generateTypes )
		{
			GenerateAttributeErrorTestClass( typeNameMember, testCase.Known, testCase.Runtime, "FileSystemEntry", "FileEntry", String.Empty );
		}

		if ( generateMethods )
		{
			GenerateAttributeErrorTestMethod( testCase.Name + "Member", typeNameMember );
		}

		var typeNameCollectionItems = testCase.Name + "CollectionItem";
		if ( generateTypes )
		{
			GenerateAttributeErrorTestClass( typeNameCollectionItems, testCase.Known, testCase.Runtime, "IList<FileSystemEntry>", "FileEntry", "CollectionItem" );
		}

		if ( generateMethods )
		{
			GenerateAttributeErrorTestMethod( testCase.Name + "CollectionItem", typeNameCollectionItems );
		}

		var typeNameDictionaryKeys = testCase.Name + "DictionaryKey";
		if ( generateTypes )
		{
			 GenerateAttributeErrorTestClass( typeNameDictionaryKeys, testCase.Known, testCase.Runtime, "IDictionary<FileSystemEntry, string>", "FileEntry", "DictionaryKey" );
		}

		if ( generateMethods )
		{
			GenerateAttributeErrorTestMethod( testCase.Name + "DictionaryKey", typeNameDictionaryKeys );
		}
		
		var tupleItemClassName = testCase.Name + "TupleItem";
		if ( generateTypes )
		{
#>
#if !NETFX_35 && !UNITY
		public class <#= tupleItemClassName #>
		{
<#+
	for ( var i = 0; i < testCase.Known; i++ )
	{
#>
			[MessagePackKnownTupleItemType( 1, "1", typeof( FileEntry ) )]
<#+
	}

	for ( var i = 0; i < testCase.Runtime; i++ )
	{
#>
			[MessagePackRuntimeTupleItemType( 1 )]
<#+
	}
#>
			public Tuple<FileSystemEntry> Value  { get; set; }

			public <#= tupleItemClassName #>() { }
		}
#endif // !NETFX_35 && !UNITY
<#+
		}

		if ( generateMethods )
		{
#>
#if !NETFX_35 && !UNITY
<#+
			GenerateAttributeErrorTestMethod( testCase.Name + "TupleItem", tupleItemClassName );
#>
#endif // !NETFX_35 && !UNITY
<#+
		}
	}
}

private void GenerateAbstractTypeTestClass( string typeName, string attribute, string declarationType )
{
#>

		public class <#= typeName #>
		{
<#+
			if ( attribute != null )
			{
#>
			<#= attribute #>
<#+
			}
#>
			public <#= declarationType #> Value { get; set; }

			public <#= typeName #>() { }
		}
<#+
}

private void GenerateAbstractTypeTestMethod( string typeName, string initializer, string abstractCollectionType, string concreteCollectionType, bool isCollection, bool success )
{
#>

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= typeName #>_<#= success ? "Success" : "Fail" #>()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
<#+
	if ( abstractCollectionType != null && concreteCollectionType != null )
	{
#>
			context.DefaultCollectionTypes.Register( typeof( <#= abstractCollectionType #> ), typeof( <#= concreteCollectionType #> ) );
<#+
	}
#>
			var target = new <#= typeName #> { Value = <#= initializer #> };

<#+
	if ( success )
	{
#>
			var serializer = context.GetSerializer<#= "<" + typeName + ">" #>();

			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
<#+
		if ( isCollection )
		{
#>
				Assert.That( result.Value.Count, Is.EqualTo( target.Value.Count ) );
				Assert.That( result.Value, Is.InstanceOf( target.Value.GetType() ) );
				Assert.That( result.Value, Is.EquivalentTo( target.Value ) );
<#+
		}
		else
		{
#>
				Assert.That( result.Value, Is.EqualTo( target.Value ) );
				Assert.That( result.Value, Is.InstanceOf( target.Value.GetType() ) );
<#+
		}
#>
			}
<#+
	}
	else
	{
#>
			Assert.Throws<NotSupportedException>( ()=> context.GetSerializer<#= "<" + typeName + ">" #>() );
<#+
	}
#>
		}
<#+
}

private void GenerateAttributeErrorTestClass( string typeName, int knownAttributeCount, int runtimeAttributeCount, string memberType, string knownType, string attributeQualifier )
{
#>

		public class <#= typeName #>
		{
<#+
	for ( var i = 0; i < knownAttributeCount; i++ )
	{
#>
			[MessagePackKnown<#= attributeQualifier #>Type( "1", typeof( <#= knownType #> ) )]
<#+
	}

	for ( var i = 0; i < runtimeAttributeCount; i++ )
	{
#>
			[MessagePackRuntime<#= attributeQualifier #>Type]
<#+
	}
#>
			public <#= memberType #> Value  { get; set; }

			public <#= typeName #>() { }
		}
<#+
}

private void GenerateAttributeErrorTestMethod(  string testCaseName, string typeName )
{
#>

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestAttribute_<#= testCaseName #>_Fail()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var target = new <#= typeName #>();
			Assert.Throws<SerializationException>( ()=> context.GetSerializer<#= "<" + typeName + ">" #>() );
		}
<#+
}

// Helper Methods
private static Func<string, string> GetMemberNameGenerator( TypeKind kind )
{
	return
		( kind & TypeKind.PropertyOrFieldMask ) == TypeKind.Field
		? new Func<string, string> ( parameter => Char.ToUpperInvariant( parameter[ 0 ] ) + parameter.Substring( 1 ) )
		: new Func<string, string> ( parameter => "_" + parameter );
}

// Internal Types
private struct Member
{
	public readonly string Name;
	public readonly string Type;
	public readonly PolymorphismTargets Targets;
	public readonly string[] ActualTypes;
	public readonly string InitialValue;
	public readonly string EmptyValue;
	public readonly KeyValuePair<int, string[]>[] PolymorphicTupleItemTypes;
	public readonly bool? AsObject;

	private Member( string name, string type, PolymorphismTargets targets, bool? asObject, string[] actualTypes, string emptyValue, string initialValue, KeyValuePair<int, string[]>[] polymorphicTupleItemTypes )
	{
		this.Name = name;
		this.Type = type;
		this.Targets = targets;
		this.ActualTypes = actualTypes;
		this.InitialValue = initialValue;
		this.EmptyValue = emptyValue;
		this.PolymorphicTupleItemTypes = polymorphicTupleItemTypes;
		this.AsObject = asObject;
	}

	public static Member Of( string name, string type, PolymorphismTargets targets, bool? asObject, string emptyValue, string initialValue, params string[] actualTypes )
	{
		return new Member( name, type, targets, asObject, actualTypes, emptyValue, initialValue, new KeyValuePair<int, string[]>[ 0 ] );
	}

	public static Member Of( string name, string type, bool? asObject, string initialValue, params KeyValuePair<int, string[]>[] polymorphicTupleItemTypes )
	{
		return new Member( name, type, PolymorphismTargets.TupleItem, asObject, null, "null", initialValue, polymorphicTupleItemTypes );
	}
}

private enum TypeKind
{
	PropertyOrFieldMask = 0xF,
	Field = 0x1,
	Property = 0x2,

	HasSetter = 0x10,
	IsPublicSetter = 0x20,

	IsReadOnly = 0x100,

	HasConstructor = 0x1000,

	NameIndicator = 0x10000000, // For ToString() support

	ReadWriteProperty = Property | HasSetter | IsPublicSetter | NameIndicator,
	ReadWriteField= Field| NameIndicator,
	GetOnlyCollectionProperty = Property| NameIndicator,
	PrivateSetterCollectionProperty = Property | HasSetter| NameIndicator,
	ReadOnlyCollectionField = Field | IsReadOnly| NameIndicator,
	GetOnlyPropertyAndConstructor = Property | HasConstructor| NameIndicator,
	PrivateSetterPropertyAndConstructor = Property | HasSetter | HasConstructor| NameIndicator,
	ReadOnlyFieldAndConstructor = Field | IsReadOnly | HasConstructor| NameIndicator,
}

private enum PolymorphismTargets
{
	None = 0,
	Member = 0x1,
	Key = 0x2,
	Item = 0x4,
	TupleItem = 0x8
}

public class TestTargetType
{
	public string Name { get; private set; }
	public bool IsNet35Supported { get; private set; }

	public TestTargetType( string name, bool isNet35Supported )
	{
		this.Name = name;
		this.IsNet35Supported = isNet35Supported;
	}
}
#>
